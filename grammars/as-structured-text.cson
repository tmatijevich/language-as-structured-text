scopeName: 'source.as-structured-text'
name: 'AS StructuredText'
fileTypes: [ 'st', 'var', 'typ', 'fun', 'per', 'iom', 'vvm' ]
patterns: [
  {
    comment: 'Single line comment'
    name: 'comment.line.double-slash.as-structured-test'
    match: '\\/\\/.*$'
  }
  {
    comment: 'Multi-line comment'
    name: 'comment.block.as-structured-text'
    begin: '\\(\\*'
    end: '\\*\\)'
  }
  {
    comment: 'Keywords for control statements'
    match: '(?i)(?<=\\s)(IF|THEN|ELSIF|ELSE|FOR|TO|BY|DO|CASE|OF|WHILE|REPEAT|UNTIL|EXIT|RETURN|END_(IF|FOR|CASE|REPEAT|WHILE))(?=(\\s|\\;))'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'keyword.control.as-structured-text'
    }
  }
  {
    comment: 'Keyword operators'
    match: '(?i)(?<=[\\s\\(])(AND|OR|XOR|NOT|MOD|ACCESS)(?=\\s)'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'keyword.operator.as-structured-text'
    }
  }
  {
    comment: 'Symbolic operators'
    name: 'keyword.operator.as-structured-text'
    match: '(\\:\\=|\\:|\\=|\\<\\>|\\>|\\<|\\>=|\\<=|\\+|\\-|\\/|\\*)'
  }
  {
    comment: 'Keywords specific to Automation Studio'
    match: '(?i)(?<=\\s)(_(INIT|CYCLIC|EXIT))(?=\\s)'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'storage.modifier.as-structured-text'
    }
  }
  {
    comment: 'True and false keywords'
    match: '(?i)(?<=\\s)(TRUE|FALSE)(?=[\\s\\;\\)])'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'constant.language.as-structured-text'
    }
  }
  {
    comment: 'Subroutine keywords'
    match: '(?i)^\\s*(FUNCTION|FUNCTION_BLOCK|PROGRAM|ACTION|END_(FUNCTION|FUNCTION_BLOCK|PROGRAM|ACTION))\\b'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'support.function.as-structured-text'
    }
  }
  {
    comment: 'Data structure declaration keywords'
    match: '(?i)^\\s*(TYPE|STRUCT|END_(TYPE|STRUCT))\\b'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'support.type.as-structured-text'
    }
  }
  {
    comment: 'Variable declaration keywords'
    match: '(?i)^\\s*(VAR|VAR_INPUT|VAR_IN_OUT|VAR_OUTPUT|VAR_CONFIG|END_VAR)\\b'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'support.variable.as-structured-text'
    }
  }
  {
    comment: 'IEC 61131 data types'
    match: '(?i)\\b(BOOL|BYTE|D?WORD|U?SINT|U?INT|U?DINT|L?REAL|W?STRING|TIME|DATE_AND_TIME|DATE|TIME_OF_DAY)\\b'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'support.storage.type.as-structured-text'
    }
  }
  {
    comment: 'Constant variable type'
    match: '(?i)(?<=VAR)\\s+(CONSTANT)\\b'
    captures: {
      0: name: 'meta.customkeyword.as-structured-text'
      1: name: 'support.storage.modifier.as-structured-text'
    }
  }
  {
    comment: 'Dot notation for structures'
    name: 'keyword.operator.as-structured-text'
    match: '(?<=[a-zA-Z_0-9\\]])\\.(?=[a-zA-Z_])'
  }
  { # Put case insensitivity identifier out front then use the case sensitive identifier later
    comment: 'Function definition name'
    name: 'entity.name.function.as-structured-text'
    match: '(?i)((?<=FUNCTION)|(?<=FUNCTION_BLOCK))(?-i)\\s+\\w+\\b'
  }
  {
    comment: 'Single quoted strings'
    name: 'string.quoted.single.as-structured-text'
    begin: "\\'"
    end: "\\'"
  }
  { # If clauses are not supported in this distribution of Oniguruma regex for Atom
    comment: 'Integer and floating point numeric constant'
    name: 'constant.numeric.as-structured-text'
    match: '(?<=[^a-zA-Z0-9_\\.\\#])(\\+|\\-)?[0-9]+(\\.[0-9]+)?(?=[^a-zA-Z0-9_\\.\\#])'
  }
  {
    comment: 'Time constants'
    name: 'constant.character.as-structured-text'
    match: '(?i)\\bt\\#(\\-)?([0-9]{,10}(d|h|m|s|ms)_?)+\\b'
  }
  {
    comment: 'Date constants'
    name: 'constant.character.as-structured-text'
    match: '(?i)\\bd\\#(19|20|21)\\d{2}\\-[0-1]?\\d\\-\\d{1,2}\\b'
  }
  {
    comment: 'Time of day constants'
    name: 'constant.character.as-structured-text'
    match: '''(?x)(?i) # Free space mode and case insensitive
    # Boundary and identifier
    \\b TOD \\#
    # Time hr:min:sec, three pairs of digits separated by colons
    [0-2]?\\d(\\:[0-5]?\\d){2}
    # Possible decimal precision for the seconds values
    (\\.\\d{1,3})?
    # Closing
    (\\s|\\;|\\))
    '''
  }
  {
    comment: 'Date and time constants, DT#1970-01-01-00:00:00 ... DT#2106-02-07-06:28:15'
    name: 'constant.character.as-structured-text'
    match: '''(?x)(?i) # Free space mode and case insensitive
    # Bounbary and identifier
    \\b DT \\#
    # Date year - month - day. If you have just a "1" it will be greedy
    (19|20|21)\\d{2} \\- (\\d{1,2} \\-){2}
    # Time hour : minute : second
    [0-2]?\\d (\\:[0-5]?\\d){2}
    # Closing
    (\\s|\\;|\\))
    '''
  }
  {
    comment: 'Function and function block calls'
    name: 'entity.name.function.as-structured-text'
    match: '[a-zA-Z][a-zA-Z_0-9]+(?=\\()'
  }
  {
    comment: 'Function block array element call'
    match: '''(?x) # Free space mode
    # Function block instance name required, group  1
    ([a-zA-Z][a-zA-Z_0-9]+)
    # Indexed once or none greedy, group 2
    (\\[([a-zA-Z][a-zA-Z_0-9]*|\\d{1,3})\\])
    # Lookahead for open parenthesis
    (?=\\()
    '''
    captures: 
      1: name: 'entity.name.function.as-structured-text'
  }
  # {
  #   comment: 'Top level structures (and function block inputs)'
  #   name: 'variable.other.member.as-structured-text'
  #   match: '(?<=[^a-zA-Z0-9_.])[a-zA-Z][a-zA-Z_0-9\\[\\]\\s\\+\\-]+(?=\\.)'
  # }
  {
    comment:  'User defined constants (all-caps)'
    name:     'constant.character.as-structured-text'
    match:    '(?<=[^\\.])\\b[A-Z]{1}[A-Z_0-9]{2,}(?=[^(])\\b(?=[^\\.])'
  }
  {
    comment: 'Global variables -- meta style'
    name: 'meta.bold.as-structured-text'
    match: '\\bg[A-Z_0-9][a-zA-Z_0-9]*\\b'
  }
]
